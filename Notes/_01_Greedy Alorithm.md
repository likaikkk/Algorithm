# 贪心算法

贪心算法（Greedy Algorithm）是一种基本的算法设计策略，通常用于解决优化问题。在贪心算法中，**每一步都会选择当前看起来最优的解决方案，而不考虑该选择可能对后续步骤造成的影响**。`贪心算法的主要思想是通过每一步的局部最优选择来达到全局最优解，希望通过贪心策略得到整体上的最优解。`

## 贪心算法的特点：

1. 贪心选择性质：每一步都要做出一个选择，这个选择应该是当前情况下最优的选择。
2. 无后效性：贪心选择不会影响之前已经做出的选择，也不会影响未来的选择。这意味着一旦做出了贪心选择，就不会改变。

## 具体例子

当谈到贪心算法时，以下是一些具体的例子，展示了如何使用贪心策略来解决不同类型的问题：

1. 找零钱问题：假设你需要找零一定金额的钱，你可以使用贪心算法，优先选择最大面额的货币，以尽量减少硬币或纸币的数量。

2. 活动选择问题：在一系列活动中选择最大数量的互不冲突的活动，例如在一个会议日程中安排尽可能多的会议，使得不会有时间冲突。

3. 霍夫曼编码：在数据压缩中，使用贪心算法来构建霍夫曼树，以便生成最优的变长编码，用于压缩数据。

4. 最小生成树问题：在一个连通的带权图中，贪心算法可以用于选择边，以构建一个包含所有节点的最小生成树，例如 Prim 算法和 Kruskal 算法。

5. 最短路径问题：在一个带权图中，使用贪心算法来选择路径上的边，以找到从一个节点到另一个节点的最短路径，例如 Dijkstra 算法。

6. 背包问题：在给定容量限制的情况下，选择价值最高的物品来放入背包，以最大化总价值，这通常可以使用贪心算法来解决，但有时需要动态规划来得到最优解。

### 找零钱问题

找零钱问题（Coin Change Problem）是一个经典的贪心算法应用示例，其目标是确定如何用最少数量的硬币来凑成特定金额的零钱。这个问题可以用来练习贪心算法，其中贪心策略是优先选择最大面额的硬币。

以下是一个详细的解释和示例：

假设有一组不同面额的硬币，例如 1 元、5 元、10 元、25 元和 50 元。现在你需要凑出一定金额的零钱，例如 63 元。问题是，如何用最少数量的硬币来凑出 63 元？

贪心策略： 在找零钱问题中，贪心策略是优先选择最大面额的硬币，以便尽量减少需要的硬币数量。这是因为大面额的硬币通常更有价值，所以使用它们可以减少硬币的数量。

解决步骤：

初始化一个变量 totalCoins 用于记录所需硬币的总数，初始值为 0。

从最大面额的硬币开始，即 50 元硬币。检查是否可以用当前面额的硬币来凑出目标金额（63 元）。

如果可以，尽可能多地使用当前面额的硬币，并更新 totalCoins 和目标金额。

如果无法再使用当前面额的硬币来凑出目标金额，继续下一个较小的面额硬币，例如 25 元硬币。

重复步骤 3 和步骤 4，直到目标金额为 0。

示例：

让我们使用上面提到的硬币面额来解决问题，凑出 63 元：

开始时，目标金额是 63 元，totalCoins 初始化为 0。
我们选择最大面额的硬币 50 元，可以使用一枚，更新 totalCoins 为 1，目标金额减少到 13 元。
接下来，我们选择次大面额的硬币 10 元，可以使用一枚，更新 totalCoins 为 2，目标金额减少到 3 元。
再次选择次大面额的硬币 1 元，可以使用 3 枚，更新 totalCoins 为 5，目标金额减少到 0。
现在，我们已经用了 5 枚硬币来凑出 63 元，这是最少数量的硬币，所以答案是 5。

这个示例展示了如何使用贪心策略来解决找零钱问题。贪心算法在这种情况下提供了最优解，但请注意，不是所有的找零问题都可以使用贪心算法得到最优解，具体情况取决于硬币面额的组合。

具体代码见
