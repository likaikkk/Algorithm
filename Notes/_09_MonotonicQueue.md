# 单调队列

## 引入

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如：

The array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。

![](https://cdn.luogu.com.cn/upload/pic/688.png)

## 定义

顾名思义，单调队列的重点分为「单调」和「队列」。

「单调」指的是元素的「规律」——递增（或递减）。

「队列」指的是元素只能从队头和队尾进行操作。

Ps. 单调队列中的 "队列" 与正常的队列有一定的区别

## 例题分析

### 解释

有了上面「单调队列」的概念，很容易想到用单调队列进行优化。

要求的是每连续的 k 个数中的最大（最小）值，很明显，当一个数进入所要 "寻找" 最大值的范围中时，若这个数比其前面（先进队）的数要大，显然，前面的数会比这个数先出队且不再可能是最大值。

也就是说——当满足以上条件时，可将前面的数 "弹出"，再将该数真正 push 进队尾。

这就相当于维护了一个递减的队列，符合单调队列的定义，减少了重复的比较次数，不仅如此，由于维护出的队伍是查询范围内的且是递减的，队头必定是该查询区域内的最大值，因此输出时只需输出队头即可。

显而易见的是，在这样的算法中，每个数只要进队与出队各一次，因此时间复杂度被降到了 O(N)。

而由于查询区间长度是固定的，超出查询空间的值再大也不能输出，因此还需要 site 数组记录第 i 个队中的数在原数组中的位置，以弹出越界的队头。

### 过程

例如我们构造一个单调递增的队列会如下：

原序列为：

```text
1 3 -1 -3 5 3 6 7
```

因为我们始终要维护队列保证其 **递增** 的特点，所以会有如下的事情发生：

| 操作                                             | 队列状态  |
| ------------------------------------------------ | --------- |
| 1 入队                                           | `{1}`     |
| 3 比 1 大，3 入队                                | `{1 3}`   |
| -1 比队列中所有元素小，所以清空队列 -1 入队      | `{-1}`    |
| -3 比队列中所有元素小，所以清空队列 -3 入队      | `{-3}`    |
| 5 比 -3 大，直接入队                             | `{-3 5}`  |
| 3 比 5 小，5 出队，3 入队                        | `{-3 3}`  |
| -3 已经在窗体外，所以 -3 出队；6 比 3 大，6 入队 | `{3 6}`   |
| 7 比 6 大，7 入队                                | `{3 6 7}` |

### 核心代码

```cpp
void getMin() {//单调递增队列
    int head = 1, tail = 0;
    for (int i = 1;i <= n;i++) {
        while (head <= tail && a[q[tail]] >= a[i])//当队列不为空且队尾元素大于新元素时，tail回退，直到小于新元素
            tail--;
        q[++tail] = i;//更新tail
        if (q[head] < i - k + 1)//如果head超出k的范围，head++
            head++;
        if (i >= k)
            cout << a[q[head]] << " ";
    }
}
```
