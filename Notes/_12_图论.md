# 图论部分简介

**图论 (Graph theory)** 是数学的一个分支，图是图论的主要研究对象。图 (Graph) 是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。

# 图论相关概念

## 图

**图 (graph)** 是一个二元组 $G=(V(G), E(G))$。其中 $V(G)$ 是非空集，称为 **点集 (vertex set)**，对于 V 中的每个元素，我们称其为 **顶点 (vertex) 或 节点 (node)**，简称 **点**；$E(G) 为 V(G)$ 各结点之间边的集合，称为 **边集 (edge set)**。

常用 G=(V,E) 表示图。

当 V,E 都是有限集合时，称 G 为 **有限图**。

当 V 或 E 是无限集合时，称 G 为 **无限图**。

图有多种，包括 **无向图 (undirected graph)**，**有向图 (directed graph)**，**混合图 (mixed graph)** 等。

若 G 为无向图，则 E 中的每个元素为一个无序二元组 (u, v)，称作 **无向边 (undirected edge)**，简称 **边 (edge)**，其中 $u, v \in V$。设 e = (u, v)，则 u 和 v 称为 e 的 **端点 (endpoint)**。

若 G 为有向图，则 E 中的每一个元素为一个有序二元组 (u, v)，有时也写作 $u \to v$，称作 **有向边** (directed edge) 或 **弧** (arc)，在不引起混淆的情况下也可以称作 **边 (edge)**。设 $e = u \to v$，则此时 u 称为 e 的 **起点 (tail)**，v 称为 e 的 **终点 (head)**，起点和终点也称为 e 的 **端点 (endpoint)**。并称 u 是 v 的直接前驱，v 是 u 的直接后继。

> 为什么起点是 tail，终点是 head
>
> > 边通常用箭头表示，而箭头是从[尾]指向[头]的。

若 G 为混合图，则 E 中既有 **有向边**，又有 **无向边**。

若 G 的每条边 $e_k=(u_k,v_k)$ 都被赋予一个数作为该边的 **权**，则称 G 为 **赋权图**。如果这些权都是正实数，就称 G 为 **正权图**。

图 G 的点数 $\left| V(G) \right|$ 也被称作图 G 的 **阶 (order)**。

形象地说，图是由若干点以及连接点与点的边构成的。

## 相邻

在无向图 G = (V, E) 中，若点 v 是边 e 的一个端点，则称 v 和 e 是 **关联的 (incident)** 或 **相邻的 (adjacent)**。对于两顶点 u 和 v，若存在边 (u, v)，则称 u 和 v 是 **相邻的 (adjacent)**。

一个顶点 $v \in V$ 的 **邻域 (neighborhood)** 是所有与之相邻的顶点所构成的集合，记作 $N(v)$。

一个点集 S 的邻域是所有与 S 中至少一个点相邻的点所构成的集合，记作 N(S)，即：

$N(S) = \bigcup\ _{v \in S} N(v)$

## 度数

与一个顶点 v 关联的边的条数称作该顶点的 **度 (degree)**，记作 d(v)。特别地，对于边 (v, v)，则每条这样的边要对 d(v) 产生 2 的贡献。

对于无向简单图，有 d(v) = $\left| N(v) \right|$。

**握手定理（又称图论基本定理）**：对于任何无向图 G = (V, E)，有 $\sum_{v \in V} d(v) = 2 \left| E \right|$。

推论：**在任意图中，度数为奇数的点必然有偶数个**。

若 d(v) = 0，则称 v 为 **孤立点 (isolated vertex)**。

若 d(v) = 1，则称 v 为 **叶节点 (leaf vertex)/悬挂点 (pendant vertex)**。

若 $2 \mid d(v)$，则称 v 为 **偶点 (even vertex)**(其度数（即与该顶点相邻的边的数量）是偶数)。

若 $2 \nmid d(v)$，则称 v 为 **奇点 (odd vertex)**(其度数是奇数)。**图中奇点的个数是偶数**。

若 $d(v) = \left| V \right| - 1$，则称 v 为 **支配点 (universal vertex)**。

对一张图，所有节点的度数的最小值称为 G 的 **最小度 (minimum degree)**，记作 $\delta (G)$；最大值称为 **最大度 (maximum degree)**，记作 $\Delta (G)$。即：$\delta (G) = \min_{v \in G} d(v)$，$\Delta (G) = \max_{v \in G} d(v)$。

在有向图 G = (V, E) 中，以一个顶点 v 为起点的边的条数称为该顶点的 **出度 (out-degree)**，记作 $d^+(v)$。以一个顶点 v 为终点的边的条数称为该节点的 **入度 (in-degree)**，记作 $d^-(v)$。显然 $d^+(v)+d^-(v)=d(v)$。

对于任何有向图 G = (V, E)，有：

$\sum_{v \in V} d^+(v) = \sum_{v \in V} d^-(v) = \left| E \right|$

若对一张无向图 G = (V, E)，每个顶点的度数都是一个固定的常数 k，则称 G 为 $k-$ **正则图 (k-regular graph)**。

如果给定一个序列 a，可以找到一个图 G，以其为度数列，则称 a 是 **可图化** 的。

如果给定一个序列 a，可以找到一个简单图 G，以其为度数列，则称 a 是 **可简单图化** 的。

## 简单图

**自环 (loop)**：对 E 中的边 e = (u, v)，若 u = v，则 e 被称作一个自环。

**重边 (multiple edge)**：若 E 中存在两个完全相同的元素（边）$e_1$, $e_2$，则它们被称作（一组）重边(在两点之间有多条边连接)。

**简单图 (simple graph)**：若一个图中没有自环和重边，它被称为简单图。具有至少两个顶点的简单无向图中一定存在度相同的结点。（[鸽巢原理](http://oi-wiki.com/math/combinatorics/drawer-principle/)）

如果一张图中有自环或重边，则称它为 **多重图 (multigraph)**。

> 在无向图中 (u, v) 和 (v, u) 算一组重边，而在有向图中，$u \to v$ 和 $v \to u$ 不为重边。

## 路径

**途径 (walk)**：途径是连接一连串顶点的边的序列，可以为有限或无限长度。形式化地说，一条有限途径 w 是一个边的序列 $e_1, e_2, \ldots, e_k$，使得存在一个顶点序列 $v_0, v_1, \ldots, v_k$ 满足 $e_i = (v_{i-1}, v_i)$，其中 $i \in [1, k]$。这样的途径可以简写为 $v_0 \to v_1 \to v_2 \to \cdots \to v_k$。通常来说，边的数量 k 被称作这条途径的 长度（如果边是带权的，长度通常指途径上的边权之和，题目中也可能另有定义）。

**迹 (trail)**：对于一条途径 w，若 $e_1, e_2, \ldots, e_k$ 两两互不相同，则称 w 是一条迹。

**路径 (path)**（又称 **简单路径 (simple path)**）：对于一条迹 w，若其连接的点的序列中点两两不同，则称 w 是一条路径。（**点可以重复但边不重复**）

**基本路径：点和边都不重复。**

> 单独一个结点 v 也可以是路径，是长度为 0 的基本路径。因此，任意结点到其自身总存在路径。

**回路(闭合路径) (circuit)**：对于一条迹 w，若 $v_0 = v_k$，则称 w 是一条回路。

**环/圈 (cycle)**（又称 **简单回路/简单环 (simple circuit)**）：对于一条回路 w，若 $v_0 = v_k$ 是点序列中唯一重复出现的点对，则称 w 是一个环。

> 关于路径的定义在不同地方可能有所不同，如，「路径」可能指本文中的「途径」，「环」可能指本文中的「回路」。如果在题目中看到类似的词汇，且没有「简单路径」/「非简单路径」（即本文中的「途径」）等特殊说明，最好询问一下具体指什么。

## 子图

对一张图 G = (V, E)，若存在另一张图 H = (V', E') 满足 $V' \subseteq V$ 且 $E' \subseteq E$，则称 H 是 G 的 **子图 (subgraph)**，记作 $H \subseteq G$。

若对 $H \subseteq G$，满足 $\forall u$, $v \in V'$，只要 $(u, v) \in E$，均有 $(u, v) \in E'$，则称 H 是 G 的 **导出子图/诱导子图 (induced subgraph)**。

> 子图和导出子图主要区别：
>
> 在于导出子图强调了选择节点**并保留节点之间的直接连接边**，而普通的子图可以包括从原始图中选择的节点和边，但**不强调是否包括所有直接连接边**。导出子图是子图的一种特例，用于特定的图分析任务，通常强调与所选节点集相关的结构。

容易发现，一个图的导出子图仅由子图的点集决定，因此点集为 $V'(V' \subseteq V)$ 的导出子图称为 V' 导出的子图，记作 $G \left[ V' \right]$。

若 $H \subseteq G$ 满足 V' = V，则称 H 为 G 的 **生成子图/支撑子图 (spanning subgraph)**。**生成子图即点一样多，但是边不一样多。**

> 生成子图强调了**包含原始图中的所有节点**，并且保持了图的连通性，而一般的子图可以是原始图的任何子集，**不一定要包括所有的节点**。生成子图通常用于连通性和路径问题，而一般的子图用于更一般的图分析和图理论问题。

显然，G 是自身的子图，支撑子图，导出子图；无边图 是 G 的支撑子图。原图 G 和无边图都是 G 的平凡子图。

如果一张无向图 G 的某个生成子图 F 为 $k-$ 正则图，则称 F 为 G 的一个 **k- 因子 (k-factor)。**

如果有向图 G = (V, E) 的导出子图 $H = G \left[ V^\ast \right]$ 满足 $\forall v \in V^\ast, (v, u) \in E$，有 $u \in V^\ast$，则称 H 为 G 的一个 **闭合子图 (closed subgraph)**。

> 这个定义描述了一个在原始有向图 G 中选择了一个节点子集 V*，并构建了一个子图 H，其中的节点都是 V* 中的节点，并且 H 中的每个节点都至少有一条边指向 H 中的另一个节点。这个定义中的导出子图 H 被称为 G 的闭合子图，因为它是一个相对于原始图 G 而言具有一定封闭性质的子图。

## 连通

### 无向图

对于一张无向图 $G = (V, E)$，对于 $u, v \in V$，若存在一条途径使得 $v_0 = u, v_k = v$，则称 $u$ 和 $v$ 是 **连通的 (connected)**。由定义，任意一个顶点和自身连通，任意一条边的两个端点连通。

若无向图 $G = (V, E)$，满足其中任意两个顶点均连通，则称 $G$ 是 **连通图 (connected graph)**，$G$ 的这一性质称作 **连通性 (connectivity)**。

若 $H$ 是 $G$ 的一个连通子图，且不存在 $F$ 满足 $H\subsetneq F \subseteq G$ 且 $F$ 为连通图，则 $H$ 是 $G$ 的一个 **连通块/连通分量 (connected component)**（极大连通子图）。

### 有向图

对于一张有向图 $G = (V, E)$，对于 $u, v \in V$，若存在一条途径使得 $v_0 = u, v_k = v$，则称 $u$ **可达** $v$。由定义，任意一个顶点可达自身，任意一条边的起点可达终点。（无向图中的连通也可以视作双向可达。）

若一张有向图的节点两两互相可达，则称这张图是 **强连通的 (strongly connected)**。

若一张有向图的边替换为无向边后可以得到一张连通图，则称原来这张有向图是 **弱连通的 (weakly connected)**。

与连通分量类似，也有 **弱连通分量 (weakly connected component)**（极大弱连通子图）和 **强连通分量 (strongly connected component)**（极大强连通子图）。

相关算法请参见 [强连通分量](./scc.md)。

## 稀疏图/稠密图

若一张图的边数远小于其点数的平方，那么它是一张 **稀疏图 (sparse graph)**。

若一张图的边数接近其点数的平方，那么它是一张 **稠密图 (dense graph)**。

这两个概念并没有严格的定义，一般用于讨论 时间复杂度 为$O(|V|^2)$ 的算法与 $O(|E|)$的算法的效率差异（在稠密图上这两种算法效率相当，而在稀疏图上 $O(|E|)$的算法效率明显更高)。

# 图的存储

## 约定

本文默认读者已阅读并了解了 [图论相关概念](./concept.md) 中的基础内容，如果在阅读中遇到困难，也可以在 [图论相关概念](./concept.md) 中进行查阅。

在本文中，用 $n$ 代指图的点数，用 $m$ 代指图的边数，用 $d^+(u)$ 代指点 $u$ 的出度，即以 $u$ 为出发点的边数。

## 直接存边

### 方法

使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权。）

```cpp
#include <iostream>
#include <vector>

using namespace std;

// 定义表示图的边的结构体
struct Edge {
    int u, v; // 边的两个端点
};

int n, m; // n代表顶点数，m代表边数
vector<Edge> e; // 存储图的边的向量
vector<bool> vis; // 用于记录顶点的访问状态的向量

// 查找是否存在边 (u, v) 的函数
bool find_edge(int u, int v) {
    for (int i = 1; i <= m; ++i) { // 遍历所有边
        if (e[i].u == u && e[i].v == v) { // 如果找到匹配的边
            return true; // 返回true，表示存在这条边
        }
    }
    return false; // 遍历完所有边都没有找到匹配的边，返回false，表示不存在这条边
}

// 深度优先搜索函数，用于遍历图
void dfs(int u) {
    if (vis[u]) return; // 如果顶点u已经被访问过，直接返回，避免重复访问
    vis[u] = true; // 标记顶点u为已访问

    for (int i = 1; i <= m; ++i) { // 遍历所有边
        if (e[i].u == u) { // 如果边的起点是顶点u
            dfs(e[i].v); // 递归访问与顶点u相邻的顶点e[i].v
        }
    }
}

int main() {
    cin >> n >> m; // 从标准输入读取顶点数n和边数m

    vis.resize(n + 1, false); // 初始化vis向量，大小为n+1，所有元素初始为false
    e.resize(m + 1); // 初始化e向量，大小为m+1

    for (int i = 1; i <= m; ++i) {
        cin >> e[i].u >> e[i].v; // 从标准输入读取边的信息，存储在e向量中
    }

    return 0; // 程序结束
}

```

### 复杂度

查询是否存在某条边：$O(m)$。

遍历一个点的所有出边：$O(m)$。

遍历整张图：$O(nm)$。

空间复杂度：$O(m)$。

### 应用

由于直接存边的遍历效率低下，一般不用于遍历图。

在 [Kruskal 算法](./mst.md#kruskal-算法) 中，由于需要将边按边权排序，需要直接存边。

在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重新建图时利用直接存下的边来建图。

## 邻接矩阵

### 方法

使用一个二维数组 `adj` 来存边，其中 `adj[u][v]` 为 1 表示存在 $u$ 到 $v$ 的边，为 0 表示不存在。如果是带边权的图，可以在 `adj[u][v]` 中存储 $u$ 到 $v$ 的边的边权。

```cpp
//2023/10/8
#include<iostream>
#include<vector>

using namespace std;

int n, m;
vector<bool>vis;
vector<vector<bool>>adj;//邻接矩阵，用来表示图的连接关系

//判断是否存在边(u,v)
bool find_edge(int u, int v) {
    return adj[u][v];
}

//深度优先搜索遍历图
void dfs(int u) {
    if (vis[u])
        return;
    vis[u] = true;
    for (int v = 1;v <= n;v++) {
        if (adj[u][v])
            dfs(v);
    }
}
int main() {
    cin >> n >> m; // 从标准输入读取顶点数n和边数m

    vis.resize(n + 1, false); // 初始化vis向量，大小为n+1，所有元素初始为false
    adj.resize(n + 1, vector<bool>(n + 1, false)); // 初始化邻接矩阵adj，大小为(n+1) x (n+1)，所有元素初始为false

    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u][v] = true; // 标记有边(u, v)
    }

    return 0; // 程序结束
}

```

### 复杂度

查询是否存在某条边：$O(1)$。

遍历一个点的所有出边：$O(n)$。

遍历整张图：$O(n ^ 2)$。

空间复杂度：$O(n ^ 2)$。

### 应用

邻接矩阵只适用于没有重边（或重边可以忽略）的情况。

其最显著的优点是可以 $O(1)$ 查询一条边是否存在。

由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。

## 邻接表

### 方法

使用一个支持动态增加元素的数据结构构成的数组，如 `vector<int> adj[n + 1]` 来存边，其中 `adj[u]` 存储的是点 $u$ 的所有**出边**的相关信息（终点、边权等）。

### 复杂度

查询是否存在 $u$ 到 $v$ 的边：$O(d^+(u))$（如果事先进行了排序就可以使用 [二分查找](../basic/binary.md) 做到 $O(\log(d^+(u)))$）。

遍历点 $u$ 的所有出边：$O(d^+(u))$。

遍历整张图：$O(n+m)$。

空间复杂度：$O(m)$。

### 应用

存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）。

尤其适用于需要对一个点的所有出边进行排序的场合。

## 链式前向星

### 方法

本质上是用链表实现的邻接表，核心代码如下：

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int MAXN = 10005; // 最大顶点数和边数

int n, m, cnt;
struct Edge
{
    int to, w, next;
}edge[MAXN];
int head[MAXN];
void init() {
    for (int i = 0;i <= n;i++)
        head[i] = -1;
    cnt = 0;
}
void add(int u, int v, int w) {
    edge[cnt].to = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt++;
}

int main() {
    cin >> n >> m;
    int u, v, w;
    init();
    for (int i = 1;i <= m;i++) {
        cin >> u >> v >> w;
        add(u, v, w);
    }
    for (int i = 1;i <= n;i++) {
        cout << i << endl;
        for (int j = head[i];j != -1;j = edge[j].next)
            cout << i << " " << edge[j].to << " " << edge[j].w << endl;
        cout << endl;
    }
    return 0;
}
```

### 复杂度

查询是否存在 $u$ 到 $v$ 的边：$O(d^+(u))$。

遍历点 $u$ 的所有出边：$O(d^+(u))$。

遍历整张图：$O(n+m)$。

空间复杂度：$O(m)$。

### 应用

存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序。

优点是边是带编号的，有时会非常有用，而且如果 `cnt` 的初始值为奇数，存双向边时 `i ^ 1` 即是 `i` 的反边（常用于 [网络流](./flow.md)）。

# DFS（图论）

## 引入

DFS 全称是 Depth First Search，中文名是深度优先搜索，是一种用于遍历或搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。

该算法讲解时常常与 BFS 并列，但两者除了都能遍历图的连通块以外，用途完全不同，很少有能混用两种算法的情况。

DFS 常常用来指代用递归函数实现的搜索，但实际上两者并不一样。有关该类搜索思想请参阅 [DFS（搜索）](http://oi-wiki.com/search/dfs/).

## 过程

DFS 最显著的特征在于其 **递归调用自身**。同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 **每个点仅访问一次**。符合以上两条规则的函数，便是广义上的 DFS。

具体地说，DFS 大致结构如下：

```text
DFS(v) // v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。
  在 v 上打访问标记
  for u in v 的相邻节点
    if u 没有打过访问标记 then
      DFS(u)
    end
  end
end
```

以上代码只包含了 DFS 必需的主要结构。实际的 DFS 会在以上代码基础上加入一些代码，利用 DFS 性质进行其他操作。

## 性质

该算法通常的时间复杂度为 O(n+m)，空间复杂度为 O(n)，其中 n 表示点数，m 表示边数。注意空间复杂度包含了栈空间，栈空间的空间复杂度是 O(n) 的。在平均 O(1) 遍历一条边的条件下才能达到此时间复杂度，例如用前向星或邻接表存储图；如果用邻接矩阵则不一定能达到此复杂度。

# BFS（图论）

BFS 全称是 Breadth First Search，中文名是宽度优先搜索，也叫广度优先搜索。

是图上最基础、最重要的搜索算法之一。

所谓宽度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。

这样做的结果是，BFS 算法找到的路径是从起点开始的 **最短** 合法路径。换言之，这条路径所包含的边数最小。

在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。

算法过程可以看做是图上火苗传播的过程：最开始只有起点着火了，在每一时刻，有火的节点都向它相邻的所有节点传播火苗。

## 实现

# 树上问题

# 矩阵树定理

# 有向无环图

# 拓扑排列

# 最小生成树

# 斯坦纳树

# 最小树形图

# 最小直径生成树
