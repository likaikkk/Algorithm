# 二分法

## 定义

二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。

## 过程

以在一个升序数组中查找一个数为例。

它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。

## 性质

### 时间复杂度

二分查找的最优时间复杂度为 O(1)。

二分查找的平均时间复杂度和最坏时间复杂度均为 $O(\log n)$。因为在二分搜索过程中，算法每次都把查询的区间减半，所以对于一个长度为 n 的数组，至多会进行 $O(\log n)$ 次查找。

### 空间复杂度

迭代版本的二分查找的空间复杂度为 O(1)。

递归（无尾调用消除）版本的二分查找的空间复杂度为 $O(\log n)$。

## 实现

```cpp
int binary_search(int start,int end,int key){
    int ret = -1;//未搜索到数据返回-1下标
    int mid;
    while(start <= end){
        mid = start + ((end-start)>>1);//直接平均可能会溢出，所以用移位运算
        if(arr[mid] < key)
            start = mid + 1;
        else if(arr[mid] > key)
            end = mid -1;
        else{
            ret = mid;
            break;
        }
    }
    return ret;
}
```

## STL 的二分查找

C++ 标准库中实现了查找首个不小于给定值的元素的函数 `std::lower_bound` 和查找首个大于给定值的元素的函数 `std::upper_bound`，二者均定义于头文件 <algorithm> 中。

二者均采用二分实现，所以调用前必须保证元素有序。

## 二分答案

解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了「二分答案」。

[P1873 砍树](https://www.luogu.com.cn/problem/P1873)

> 伐木工人米尔科需要砍倒 M 米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。
>
> 米尔科的伐木机工作过程如下：米尔科设置一个高度参数 H（米），伐木机升起一个巨大的锯片到高度 H，并锯掉所有的树比 H 高的部分（当然，树木不高于 H 米的部分保持不变）。米尔科就得到树木被锯下的部分。
>
> 例如，如果一行树的高度分别为 20,~15,~10,~17，米尔科把锯片升到 15 米的高度，切割后树木剩下的高度将是 15,~15,~10,~15，而米尔科将从第 1 棵树得到 5 米木材，从第 4 棵树得到 2 米木材，共 7 米木材。
>
> 米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他尽可能高地设定伐木机锯片的原因。你的任务是帮助米尔科找到伐木机锯片的最大的整数高度 H，使得他能得到木材至少为 M 米。即，如果再升高 1 米锯片，则他将得不到 M 米木材。

解题思路

> 我们可以在 1 到 $10^9$ 中枚举答案，但是这种朴素写法肯定拿不到满分，因为从 1 枚举到 $10^9$ 太耗时间。我们可以在 $[1,~10^9]$ 的区间上进行二分作为答案，然后检查各个答案的可行性（一般使用贪心法）。这就是**二分答案**。

# 三分法

## 引入

如果需要求出**单峰函数**的**极值点**，通常使用二分法衍生出的三分法求单峰函数的极值点。

> **注意**：
>
> 只要函数是单峰函数，三分法既可以求出其最大值，也可以求出其最小值。为行文方便，除特殊说明外，下文中均以求单峰函数的最小值为例。

三分法与二分法的基本思想类似，但每次操作需在当前区间 $[l,r]$（下图中除去虚线范围内的部分）内任取两点 $lmid,rmid(lmid < rmid)$（下图中的两蓝点）。如下图，如果 $f(lmid)<f(rmid)$，则在 $[rmid,r]$（下图中的红色部分）中函数必然单调递增，最小值所在点（下图中的绿点）必然不在这一区间内，可舍去这一区间。反之亦然。
![](http://oi-wiki.com/basic/images/binary1.svg)
三分法每次操作会舍去两侧区间中的其中一个。为减少三分法的操作次数，应使两侧区间尽可能大。因此，每一次操作时的 $lmid$ 和 $rmid$ 分别取 $mid-\varepsilon$ 和 $mid+\varepsilon$ 是一个不错的选择。

## 实现

```cpp
while(r-l>eps){
    mid=(lmid+rmid)/2;
    lmid = mid - eps;
    rmid = mid + eps;
    if(f(lmid)<f(rmid))
        r=mid;
    else
        l=mid;
}
```

## 例题

[洛谷 P3382 -【模板】三分法](https://www.luogu.com.cn/problem/P3382)
